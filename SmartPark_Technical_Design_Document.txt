SmartPark - Technical Design Document (TDD)1. System OverviewSmartPark is a multi-camera vehicle counting and floor allocation system.It detects vehicles entering and exiting parking floors, maintains real-time occupancy,and provides floor recommendations via API and dashboard.2. High-Level ArchitectureCamera (RTSP / MP4)? Vision Service (YOLOv8 + ByteTrack + OpenCV)? Line Crossing Logic? FastAPI Backend? Database (SQLite / PostgreSQL)? Allocation Engine? Dashboard + Ticket API3. Component ResponsibilitiesVision Service: Detect vehicles, track IDs, detect line crossing, send events.Backend Service: Validate events, update counts, store logs, calculate availability.Database: Persistent storage for floors and event logs.4. Event Data Flow1. Vision service detects line crossing.2. Structured event is generated and sent to POST /event.3. Backend validates and checks duplicates.4. Database transaction updates vehicle count.5. Availability recalculated and dashboard updated.5. Event Idempotency StrategyPrevent duplicate events using unique constraints on camera_id, track_id, direction, and timestamp window.Backend rejects duplicate event submissions.6. Line Crossing LogicDefine virtual line per camera.Detect centroid crossing from side A to side B.Trigger single event per track ID per crossing.7. Database SchemaFloors Table: id, name, total_slots, current_vehicles, updated_at.Events Table: id, camera_id, floor_id, track_id, vehicle_type, direction, timestamp.8. Floor Allocation AlgorithmQuery all floors.Filter floors with available_slots > threshold.Sort by highest available slots or nearest floor.Return recommended floor and availability.9. Concurrency HandlingUse database transactions.Ensure atomic increment/decrement operations.Avoid in-memory state for vehicle counts.10. Failure HandlingVision crash: Auto-restart vision service.Backend restart: State restored from database.Count drift: Manual reset endpoint or reconciliation process.11. Scaling StrategyPrototype: Single-node deployment with multiple camera processes.Production: Edge devices per camera connecting to central backend.12. Performance ConsiderationsUse yolov8n model for CPU testing.Restrict detection classes to vehicles.Skip alternate frames if necessary.Target 10–15 FPS per camera on CPU.13. Security ConsiderationsValidate API payloads.Add authentication for dashboard access.Rate-limit event endpoint.14. Logging & MonitoringLog all entry/exit events.Log duplicate rejections.Log system errors and camera status.15. Prototype DeploymentRun FastAPI backend locally.Run separate vision scripts per camera.Access dashboard via browser at localhost.
